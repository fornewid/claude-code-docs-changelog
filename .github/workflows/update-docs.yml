name: Update Claude Code Documentation

on:
  schedule:
    # Run every 3 hours (at 00:00, 03:00, 06:00, 09:00, 12:00, 15:00, 18:00, 21:00 UTC)
    - cron: '0 */3 * * *'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write
  issues: write

jobs:
  update-docs:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: main
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r scripts/requirements.txt
    
    - name: Fetch latest documentation
      id: fetch-docs
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_REF_NAME: ${{ github.ref_name }}
      run: |
        python scripts/fetch_claude_docs.py || echo "fetch_failed=true" >> $GITHUB_OUTPUT
      continue-on-error: true
    
    - name: Check for changes
      id: verify-changed-files
      run: |
        git diff --exit-code || echo "changed=true" >> $GITHUB_OUTPUT
    
    - name: Summarize changes with Gemini
      if: steps.verify-changed-files.outputs.changed == 'true'
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        # Find changed markdown files (unstaged)
        # We need to handle filenames with spaces if any (though ours are safe)
        CHANGED_MD=$(git diff --name-only docs/ | grep "\.md$" || true)
        
        if [ -n "$CHANGED_MD" ]; then
          echo "Summarizing changes for: $CHANGED_MD"
          # Convert newlines to spaces for arguments
          FILES_ARGS=$(echo "$CHANGED_MD" | tr '\n' ' ')
          python scripts/summarize_changes.py --files $FILES_ARGS
        else
          echo "No markdown files changed."
        fi
    
    - name: Generate commit message
      if: steps.verify-changed-files.outputs.changed == 'true'
      id: commit-msg
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # 1. Commit documentation changes first (if any)
        git add docs/
        
        # Check if there are staged changes in docs/
        if git diff --staged --quiet docs/; then
          echo "No documentation changes to commit."
        else
          git commit -m "Update docs - $(date +'%Y-%m-%d')"
          echo "Docs committed."
        fi
        
        # 2. Get the commit hash we just made (or HEAD if no new commit)
        COMMIT_HASH=$(git rev-parse --short HEAD)
        
        # Get list of changed files in that commit (or staged if not committed? No, we just committed)
        # Actually, if we just committed, we want the diff of HEAD^..HEAD or similar.
        # But wait, if we push, we want the changes that happened.
        # Let's rely on the previous logic of detecting changes, but we need to pass the hash.
        
        # Wait, if we just committed, "git diff --cached" is empty.
        # We need to know what files changed in the specific commit we just made.
        # OR, if we didn't commit (no changes), we do nothing.
        
        # Let's refactor:
        # We need to identify changed files *before* committing to pass them to script?
        # No, the script now takes a commit hash to link to.
        # But the script also needs to know *which files* to summarize.
        # If we commit first, we can use `git show --name-status` or `git diff HEAD^ HEAD`.
        
        # Revised approach:
        # 1. Get changed files logic remains similar but looks at HEAD if committed.
        # Actually simplified:
        # Users want: "2026-01-29 {commit hash}" header.
        # We can pass the hash of the *current state* (which will be the docs commit).
        
        # Let's stick to the plan:
        # 1. Commit docs.
        # 2. Get hash.
        # 3. Identify changed files in that hash (git diff-tree or similar).
        # 4. Run script with files AND hash.
        
        # Identifying files from the latest commit (HEAD):
        # CHANGED_FILES=$(git diff-tree --no-commit-id --name-status -r HEAD | grep "^[AMD]" | grep "docs/.*\.md$" | awk '{print $1 ":" $2}' | paste -sd " " -)
        
        CHANGED_FILES=$(git diff-tree --no-commit-id --name-status -r HEAD | grep "^[AMD]" | grep "docs/.*\.md$" | awk '{print $1 ":" $2}' | paste -sd " " -)
        
        if [ -n "$CHANGED_FILES" ]; then
          echo "Detected changes in HEAD ($COMMIT_HASH): $CHANGED_FILES"
          
          # Run the summarization script with the list of changed files AND the commit hash
          python3 scripts/summarize_changes.py --commit-hash $COMMIT_HASH --files $CHANGED_FILES
          
          # 3. Commit the blog update (index.html) and JSON data (pages/)
          # Remove root index.html if it exists (migration)
          git add pages/
          git add index.html || true # Ensure root index is tracked if modified (though it shouldn't change often)
          git commit -m "Update blog (pages/) for $COMMIT_HASH"
        else
          echo "No documentation changes detected in the latest commit."
        fi
        
        # Finally, push all changes
        git push
    
    - name: Create issue on failure
      if: steps.fetch-docs.outputs.fetch_failed == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const date = new Date().toISOString().split('T')[0];
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Documentation update failed - ${date}`,
            body: `The automated documentation update failed on ${date}.\n\nPlease check the [workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.`,
            labels: ['bug', 'automation']
          })